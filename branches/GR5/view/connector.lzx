<library>
	<class name="baseconnector" extends="view" x="${b.x+b.width/2}" 
		y="${b.y+b.height/2}" width="20"
		height="300"
		xoffset="${width/2}"
		yoffset="${width/2}"
		>
		<edge name="modeledge" />
		<!-- Pointers to connected objects  -->
		<attribute name="from" />
		<attribute name="to"/>
		
		<attribute name="dx"/>
		<attribute name="dy"/>
		<method name="changeTarget" args="target">
			this.e = target;
			this.modeledge.t = target.modelnode;
			refreshConstraints();
			adjust();
		</method>
		<handler name="onconstruct">
			this.b= from;
			this.e = to;

		</handler>
		<handler name="oninit">
			adjust();
			sendToBack();
			//add pointers to the modelnodes to the modeledge
			this.modeledge.s = this.b.modelnode;
			this.modeledge.t = this.e.modelnode;
			//this.modeledge.sourceButton = null;
			refreshConstraints();
		</handler>
		<method name="refreshConstraints">
			/*
			 * So I'm going to express the connector constraints in script rather than tags so that we can easily change the nodes
			 * an edge is bound to
			 */
			var adjustDel = new LzDelegate(this, "adjust");
			adjustDel.register(b, "onx");
			adjustDel.register(b, "ony");
			adjustDel.register(e, "onx");
			adjustDel.register(e, "ony");			
  			adjustDel.register(b, "onwidth");
  			adjustDel.register(e, "onwidth");
		</method>
								
		<method name="adjust">
		    __refreshdxdy();
			setHeight(__calcHeight());
			setRotation(__calcAngle());
		</method>
		<method name="__refreshdxdy">
			/*
			 * Figure out the distance between start and endpoints
			 */
			var x1 = b.x+b.width/2;
			var y1 = b.y+b.height/2;
			var x2 = e.x+e.width/2;
			var y2 = e.y+e.height/2;
			dx = x1-x2;
	        dy = y1 - y2
		</method>
		<method name="__calcHeight">
			//distance between two points.
			return Math.sqrt(dx*dx+dy*dy);
		</method>
		<method name="__calcAngle">
		<![CDATA[
	        angle = 0;
	 		//Take care of special cases. You don't want to get division by zero errors when tan goes to infinity.
	        if (dx == 0) {
	            if(dy == 0)     angle = 0;
	            else if(dy > 0) angle = Math.PI / 2.0; //90
	            else            angle = (Math.PI * 3.0) / 2.0; //-90
	        }
	        else if(dy == 0) {
	            if(dx > 0)      angle = 0;
	            else            angle = Math.PI; //180
	        }
	        //done with special cases
	        else {
	            if(dx < 0)      angle = Math.atan(dy/dx) + Math.PI;
	            else if(dy < 0) angle = Math.atan(dy/dx) + (2*Math.PI);
	            else            angle = Math.atan(dy/dx);
	        }
	        /*
	         * add an offset of 90 because OpenLaszlo views always point downward.
	         * and then convert to degrees.
	         */
	        return (angle * 180) / Math.PI + 90;
	    ]]>
		</method>	
	</class>
	
	<!--  this connector adds more functionality to the base connector.
		Such as:
		1. arrow head to denote direction
		2. ability to highlight and unhighlight
	 -->
	<class name="connector" extends="baseconnector">
		<!--  the color of the connector -->
		<attribute name="color" type="color" value="0x00ADEF" />
		<!--  make sure to asign a resource for arrowhead -->
		<view name="arrowhead" 

		xoffset="0" ondblclick="parent.dodblclick()">
			<attribute name="resource" value="arrowhead" />
			<handler name="onrotation" reference="parent">
			<![CDATA[
				/*
				 *	we want the arrow to to be at the edge of the target node
				 *	the constraint y="${parent.height-parent.e.width/2-height}" 
				 *  makes the arrow head location be on a circle perimeter.
				 *  this is to fix it so that it would follow a rectangular perimeter.
				 */
				 
				// follow the top and bottom edges of the target node 
				var angle = parent.rotation-90;
				var thresholdAngle = Math.atan((classroot.to.width/2)/(classroot.to.height/2));
				var tAngleDeg = thresholdAngle*180/Math.PI;
				if (
					(angle >= (90-tAngleDeg)) & (angle <= (90+tAngleDeg))
					|
					(angle >= (270-tAngleDeg)) & (angle <= (270+tAngleDeg))
					) {
					var a = classroot.to.height/2;
					var theta = Math.abs(angle-90); 
					var b = a*Math.tan(toRad(theta));
					var hyp = Math.sqrt(a*a+ b*b);
					setAttribute("y", parent.height-hyp-this.height/2);
				}
				//else follow the left and right edges of the target node.
				else {
					thresholdAngle = Math.atan((classroot.to.height/2)/(classroot.to.width/2));
					tAngleDeg = thresholdAngle*180/Math.PI;
					//Debug.write(angle, tAngleDeg);
					var a = classroot.to.width/2;
					var theta = Math.abs(angle); 
					var b = a*Math.tan(toRad(theta));
					var hyp = Math.sqrt(a*a+ b*b);
					setAttribute("y", parent.height-hyp-this.height/2+2);
				}

				function toDeg(radians) {
					return radians*180/Math.PI;
				}
				
				function toRad(degrees) {
					return degrees*Math.PI/180;
				}
			]]>	
			</handler>
		</view>
		
		<!-- this view displays an icon on the edge to hint to the type 
			Note that rotation constraint to make sure the hint is always up straight
			regardless of the rotation angle of the connector.
		-->
		<view name="thint"  
		y="${parent.height/2}" 
		rotation="${-parent.rotation}"
		>
			<text fontsize="15" text="${classroot.modeledge.sourceButton}">
			<handler name="oninit">
				if (classroot.modeledge.sourceButton == null)
				{
					setText("?");
				}
			</handler>
				
			</text>
		</view>

		
		
		<!--  this is the line that actually appears inside the connector -->
		<view name="line" 
			  bgcolor="$once{parent.color}"
			  width="1"
			  xoffset="$once{-parent.width/2+width}"
			  height="${parent.height}"
		/>
		<!-- 
			TODO: factor out some of the shared functionality between nodes and connectors
			such as highlight, unhighlight, select, etc.
		 -->
		<method name="highlight">
			setBGColor("0xFFE630");
		</method>
		<method name="unhighlight">
			setBGColor(null);
		</method>
		<handler name="ondblclick">
			dodblclick();
		</handler>
		<method name="dodblclick">
			//this was factored out so that it can be used in other parts
			parent.onselectswitch.sendEvent();
			parent.setAttribute('selectedobj', this);
		</method>
		</class>
</library>